{"version":3,"sources":["vimeo-video-upload.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"video-create.js","sourcesContent":["\n\n/**\n * Helper for implementing retries with backoff. Initial retry\n * delay is 1 second, increasing by 2x (+jitter) for subsequent retries\n *\n * @constructor\n */\nvar RetryHandler = function() {\n  this.interval = 1000; // Start at one second\n  this.maxInterval = 60 * 1000; // Don't wait longer than a minute \n};\n\n/**\n * Invoke the function after waiting\n *\n * @param {function} fn Function to invoke\n */\nRetryHandler.prototype.retry = function(fn) {\n  setTimeout(fn, this.interval);\n  this.interval = this.nextInterval_();\n};\n\n/**\n * Reset the counter (e.g. after successful request.)\n */\nRetryHandler.prototype.reset = function() {\n  this.interval = 1000;\n};\n\n/**\n * Calculate the next wait time.\n * @return {number} Next wait interval, in milliseconds\n *\n * @private\n */\nRetryHandler.prototype.nextInterval_ = function() {\n  var interval = this.interval * 2 + this.getRandomInt_(0, 1000);\n  return Math.min(interval, this.maxInterval);\n};\n\n/**\n * Get a random int in the range of min to max. Used to add jitter to wait times.\n *\n * @param {number} min Lower bounds\n * @param {number} max Upper bounds\n * @private\n */\nRetryHandler.prototype.getRandomInt_ = function(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n};\n\n\n/**\n * Helper class for resumable uploads using XHR/CORS. Can upload any Blob-like item, whether\n * files or in-memory constructs.\n *\n * @example\n * var content = new Blob([\"Hello world\"], {\"type\": \"text/plain\"});\n * var uploader = new MediaUploader({\n *   file: content,\n *   token: accessToken,\n *   onComplete: function(data) { ... }\n *   onError: function(data) { ... }\n * });\n * uploader.upload();\n *\n * @constructor\n * @param {object} options Hash of options\n * @param {string} options.token Access token\n * @param {blob} options.file Blob-like item to upload\n * @param {string} [options.fileId] ID of file if replacing\n * @param {object} [options.params] Additional query parameters\n * @param {string} [options.contentType] Content-type, if overriding the type of the blob.\n * @param {object} [options.metadata] File metadata\n * @param {function} [options.onComplete] Callback for when upload is complete\n * @param {function} [options.onProgress] Callback for status for the in-progress upload\n * @param {function} [options.onError] Callback if upload fails\n */\nvar MediaUploader = function(options) {\n  var noop = function() {};\n  this.file = options.file;\n  this.contentType = options.contentType || this.file.type || 'application/octet-stream';\n  this.metadata = options.metadata || {\n    'title': this.file.name,\n    'mimeType': this.contentType\n  };\n  this.token = options.token;\n  this.upgrade_to_1080 = options.upgrade_to_1080;\n  this.onComplete = options.onComplete || noop;\n  this.onProgress = options.onProgress || noop;\n  this.onError = options.onError || noop;\n  this.offset = options.offset || 0;\n  this.chunkSize = options.chunkSize || 0;\n  this.retryHandler = new RetryHandler();\n\n  this.url = options.url;\n\n  if (!this.url) {\n    var params = options.params || {};\n    // params.uploadType = 'resumable';\n    this.url = this.buildUrl_(options.fileId, params, options.baseUrl);\n  }\n\n  this.httpMethod = options.fileId ? 'PUT' : 'POST';\n};\n\n/**\n * Initiate the upload (Get vimeo ticket number and upload url)\n */\nMediaUploader.prototype.upload = function() {\n  var self = this;\n  var xhr = new XMLHttpRequest();\n  // var upgrade_to_1080 = (this.upgrade_to_1080 == 'yes') ? true : false;\n  var upgrade_to_1080 = true;\n\n  xhr.open(this.httpMethod, this.url, true);\n  xhr.setRequestHeader('Authorization', 'Bearer ' + this.token);\n  xhr.setRequestHeader('Content-Type', 'application/json');\n\n  xhr.onload = function(e) {\n    // get vimeo upload  url, user (for available quote), ticket id and complete url\n    if (e.target.status < 400) {\n      var response = JSON.parse(e.target.responseText);\n      this.url = response.upload_link_secure;\n      this.user = response.user;\n      this.ticket_id = response.ticket_id;\n      this.complete_url = \"https://api.vimeo.com\"+response.complete_uri;\n      this.sendFile_();\n    } else {\n      this.onUploadError_(e);\n    }\n  }.bind(this);\n\n  xhr.onerror = this.onUploadError_.bind(this);\n  xhr.send(JSON.stringify({\n    type:'streaming',\n    upgrade_to_1080: upgrade_to_1080\n  }));\n\n};\n\n/**\n * Send the actual file content.\n *\n * @private\n */\nMediaUploader.prototype.sendFile_ = function() {\n  var content = this.file;\n  var end = this.file.size;\n\n  if (this.offset || this.chunkSize) {\n    // Only bother to slice the file if we're either resuming or uploading in chunks\n    if (this.chunkSize) {\n      end = Math.min(this.offset + this.chunkSize, this.file.size);\n    }\n    content = content.slice(this.offset, end);\n  }\n\n  var xhr = new XMLHttpRequest();\n  xhr.open('PUT', this.url, true);\n  xhr.setRequestHeader('Content-Type', this.contentType);\n  // xhr.setRequestHeader('Content-Length', this.file.size);\n  xhr.setRequestHeader('Content-Range', \"bytes \" + this.offset + \"-\" + (end - 1) + \"/\" + this.file.size);\n\n  if (xhr.upload) {\n    xhr.upload.addEventListener('progress', this.onProgress);\n  }\n  xhr.onload = this.onContentUploadSuccess_.bind(this);\n  xhr.onerror = this.onContentUploadError_.bind(this);\n  xhr.send(content);\n};\n\n/**\n * Query for the state of the file for resumption.\n *\n * @private\n */\nMediaUploader.prototype.resume_ = function() {\n  var xhr = new XMLHttpRequest();\n  xhr.open('PUT', this.url, true);\n  xhr.setRequestHeader('Content-Range', \"bytes */\" + this.file.size);\n  xhr.setRequestHeader('X-Upload-Content-Type', this.file.type);\n  if (xhr.upload) {\n    xhr.upload.addEventListener('progress', this.onProgress);\n  }\n  xhr.onload = this.onContentUploadSuccess_.bind(this);\n  xhr.onerror = this.onContentUploadError_.bind(this);\n  xhr.send();\n};\n\n/**\n * Extract the last saved range if available in the request.\n *\n * @param {XMLHttpRequest} xhr Request object\n */\nMediaUploader.prototype.extractRange_ = function(xhr) {\n  var range = xhr.getResponseHeader('Range');\n  if (range) {\n    this.offset = parseInt(range.match(/\\d+/g).pop(), 10) + 1;\n  }\n};\n\n/**\n * The final step is to call vimeo.videos.upload.complete to queue up\n * the video for transcoding.\n *\n * If successful call 'onComplete'\n *\n * @private\n */\nMediaUploader.prototype.complete_ = function() {\n\n  var xhr = new XMLHttpRequest();\n  xhr.open('DELETE', this.complete_url, true);\n  xhr.setRequestHeader('Authorization', 'Bearer ' + this.token);\n\n  xhr.onload = function(e) {\n\n    // Get the video location (videoId)\n    if (e.target.status < 400) {\n      // console.log(e);\n\n      var location = e.target.getResponseHeader('Location');\n\n      // Example of location: ' /videos/115365719', extract the video id only\n      var video_id = location.split('/').pop();\n\n      this.onComplete(video_id);\n\n    } else {\n      this.onCompleteError_(e);\n    }\n  }.bind(this);\n\n  xhr.onerror = this.onCompleteError_.bind(this);\n  xhr.send();\n};\n\n/**\n * Handle successful responses for uploads. Depending on the context,\n * may continue with uploading the next chunk of the file or, if complete,\n * invokes vimeo complete service.\n *\n * @private\n * @param {object} e XHR event\n */\nMediaUploader.prototype.onContentUploadSuccess_ = function(e) {\n  \n  if (e.target.status == 200 || e.target.status == 201) {\n   \n    this.complete_();\n\n  } else if (e.target.status == 308) {\n    this.extractRange_(e.target);\n    this.retryHandler.reset();\n    this.sendFile_();\n  }\n\n};\n\n/**\n * Handles errors for uploads. Either retries or aborts depending\n * on the error.\n *\n * @private\n * @param {object} e XHR event\n */\nMediaUploader.prototype.onContentUploadError_ = function(e) {\n  if (e.target.status && e.target.status < 500) {\n    this.onError(e.target.response);\n  } else {\n    this.retryHandler.retry(this.resume_.bind(this));\n  }\n};\n\n/**\n * Handles errors for the complete request.\n *\n * @private\n * @param {object} e XHR event\n */\nMediaUploader.prototype.onCompleteError_ = function(e) {\n  this.onError(e.target.response); // TODO - Retries for initial upload\n};\n\n/**\n * Handles errors for the initial request.\n *\n * @private\n * @param {object} e XHR event\n */\nMediaUploader.prototype.onUploadError_ = function(e) {\n  this.onError(e.target.response); // TODO - Retries for initial upload\n};\n\n/**\n * Construct a query string from a hash/object\n *\n * @private\n * @param {object} [params] Key/value pairs for query string\n * @return {string} query string\n */\nMediaUploader.prototype.buildQuery_ = function(params) {\n  params = params || {};\n  return Object.keys(params).map(function(key) {\n    return encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);\n  }).join('&');\n};\n\n/**\n * Build the drive upload URL\n *\n * @private\n * @param {string} [id] File ID if replacing\n * @param {object} [params] Query parameters\n * @return {string} URL\n */\nMediaUploader.prototype.buildUrl_ = function(id, params, baseUrl) {\n  var url = baseUrl || 'https://api.vimeo.com/me/videos';\n  if (id) {\n    url += id;\n  }\n  var query = this.buildQuery_(params);\n  if (query) {\n    url += '?' + query;\n  }\n  return url;\n};"],"sourceRoot":"/source/"}